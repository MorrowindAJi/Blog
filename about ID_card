虽然说不想搬运博客的内容，可是这样分开放老是感觉很不舒服，也许这就是强迫症吧——哈哈哈哈哈哈
那么搬运一下我博客的一篇关于身份证的验证吧，可以移步：http://blog.sina.com.cn/s/blog_7df716d50102xaj9.html来查看
------------------------------------------------------------------我是分割线---------------------------------
昨天和基佬讨论了一个问题，身份证的相关验证，第一意识就是正则，然后就没有了——严格来说这样并没有什么用，所以今天稍微找了一些资料来看看，其实也不难，那么开始吧——
先是城市的代码：$City = array(11=>"北京",12=>"天津",13=>"河北",14=>"山西",15=>"内蒙古",21=>"辽宁",22=>"吉林",23=>"黑龙江",31=>"上海",32=>"江苏",33=>"浙江",
34=>"安徽",35=>"福建",36=>"江西",37=>"山东",41=>"河南",42=>"湖北",43=>"湖南",44=>"广东",45=>"广西",46=>"海南",50=>"重庆",51=>"四川",52=>"贵州",53=>"云南",
54=>"西藏",61=>"陕西",62=>"甘肃",63=>"青海",64=>"宁夏",65=>"新疆",71=>"台湾",81=>"香港",82=>"澳门",91=>"国外");

然后是校验。

身份证15位升级到18位，原来年用2位且没有最后一位，从左到右方分别表示
①1-2 升级行政区代码
②3-4 地级行政区划分代码
③5-6 县区行政区分代码
④7-10 11-12 13-14 出生年、月、日
⑤15-17 顺序码，同一地区同年、同月、同日出生人的编号，奇数是男性，偶数是女性
⑥18 校验码，如果是0-9则用0-9表示，如果是10则用X（罗马数字10）表示

这里说一下很重要的一点（因为不会在GITHUB放图片，只能文字描述了），叫加权因子，共有17位。这个因子怎么来呢，我来稍微说一下：
我们已知身份证有18位，则除去最后的一位，取前17位来计算加权因子。

[1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7]，注意：该数组里不是身份证号，是身份证对应的第N位
取第一位1*2的17次方/11，会得到一个余数；
取第二位2*2的16次方/11，会得到一个余数；
同理有：
取第N位X*2的(18-N)/11，会得到一个余数。

所以通过上面的步骤，可以得到17个余数

[7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2]
则上方的数组就是我们需要的加权因子。

那么说说最后一位，我们需要用加权因子来计算最后一位，如果，第18位和我们通过加权因子计算出来的一样，那么该身份证是有效身份证，反之，是无效的身份证。下面是计算过程：
设，身份证号为：123456789123456789，取身份证前17位：12345678912345678，则有

取第一位：$a=1*2的(18-1)次方
取第二位：$a=2*2的(18-2)次方
同理：
取第N位：$a=X*2的(18-N)次方，X为身份证的号码，比如第10位，则是1
每次计算都有一个值，最后我们将所有的值相加，得到一个和，我们暂时称为$sum。
使用$sum/11会得到一个余数，
余数[0,1,2,3,4,5,6,7,8,9,10]
第十八位[1,0,X,9,8,7,6,5,4,3,2]

使用余数一一对应下方的第18位数字，如：余7，这对应18位为5
如果余数对应后，与身份证第18位相同，这是有效身份证
=========================================================================以下是相关代码============================================
（代码可以参考：http://www.thinkphp.cn/code/2147.html）
function validation_filter_id_card($id_card){
    if(strlen($id_card)==18){
        return idcard_checksum18($id_card);
    }elseif((strlen($id_card)==15)){
        $id_card=idcard_15to18($id_card);
        return idcard_checksum18($id_card);
    }else{
        return false;
    }
}
// 计算身份证校验码，根据国家标准GB 11643-1999
function idcard_verify_number($idcard_base){
    if(strlen($idcard_base)!=17){
        return false;
    }
    //加权因子
    $factor=array(7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2);
    //校验码对应值
    $verify_number_list=array('1','0','X','9','8','7','6','5','4','3','2');
    $checksum=0;
    for($i=0;$i
        $checksum += substr($idcard_base,$i,1) * $factor[$i];
    }
    $mod=$checksum % 11;
    $verify_number=$verify_number_list[$mod];
    return $verify_number;
}
// 将15位身份证升级到18位
function idcard_15to18($idcard){
    if(strlen($idcard)!=15){
        return false;
    }else{
    $regx = "/^(\d{6})+(\d{2})+(\d{2})+(\d{2})+(\d{3})$/";
if(!preg_match($regx,$idcard))
   {
       return false;
   }
        // 如果身份证顺序码是996 997 998 999，这些是为百岁以上老人的特殊编码
        if(array_search(substr($idcard,12,3),array('996','997','998','999')) !== false){
            $idcard=substr($idcard,0,6).'18'.substr($idcard,6,9);
        }else{
            $idcard=substr($idcard,0,6).'19'.substr($idcard,6,9);
        }
    }
    $idcard=$idcard.idcard_verify_number($idcard);
    return $idcard;
}
// 18位身份证校验码有效性检查
function idcard_checksum18($idcard){
    if(strlen($idcard)!=18){
        return false;
    }
$regx = "/^(\d{6})+(\d{4})+(\d{2})+(\d{2})+(\d{3})([0-9]|X)$/";
if(!preg_match($regx,$idcard))
    {
        return false;
    }
    $idcard_base=substr($idcard,0,17);
    if(idcard_verify_number($idcard_base)!=strtoupper(substr($idcard,17,1))){
        return false;
    }else{
        return true;
    }
}
调用为：validation_filter_id_card("身份证号码")。当然，别忘了做正则的身份证验证。
